Require Export chapter05.

Inductive beautiful : nat -> Prop :=
  b_0 : beautiful 0
| b_3 : beautiful 3
| b_5 : beautiful 5
| b_sum : forall n m, beautiful n -> beautiful m -> beautiful (n+m).

Theorem three_is_beautiful: beautiful 3.
Proof.
   (* This simply follows from the rule b_3. *)
   apply b_3.
Qed.

Theorem eight_is_beautiful: beautiful 8.
Proof.
   (* First we use the rule b_sum, telling Coq how to
      instantiate n and m. *)
   apply b_sum with (n:=3) (m:=5).
   (* To solve the subgoals generated by b_sum, we must provide
      evidence of beautiful 3 and beautiful 5. Fortunately we
      have rules for both. *)
   apply b_3.
   apply b_5.
Qed.

Theorem beautiful_plus_eight: forall n, beautiful n -> beautiful (8+n).
Proof.
  intros n B.
  apply b_sum with (n:=8) (m:=n).
  apply eight_is_beautiful.
  apply B.
Qed.

Theorem b_timesm: forall n m, beautiful n -> beautiful (m*n).
Proof.
  intros n m. induction m as [|p].
  Case "0". rewrite mult_0_l. intros. apply b_0.
  Case "S p". intros. simpl. apply b_sum. apply H. apply IHp. apply H.
Qed.

Inductive gorgeous : nat -> Prop :=
  g_0 : gorgeous 0
| g_plus3 : forall n, gorgeous n -> gorgeous (3+n)
| g_plus5 : forall n, gorgeous n -> gorgeous (5+n).

Theorem gorgeous_plus13: forall n, 
  gorgeous n -> gorgeous (13+n).
Proof.
  intros. apply g_plus3. apply g_plus5. apply g_plus5. apply H.
Qed.

Theorem gorgeous__beautiful : forall n, 
  gorgeous n -> beautiful n.
Proof.
   intros n H.
   induction H as [|n'|n'].
   Case "g_0".
       apply b_0.
   Case "g_plus3".
       apply b_sum. apply b_3.
       apply IHgorgeous.
   Case "g_plus5".
       apply b_sum. apply b_5. apply IHgorgeous.
Qed.

Theorem gorgeous_sum : forall n m,
  gorgeous n -> gorgeous m -> gorgeous (n + m).
Proof.
  intros n m H. generalize dependent m. induction H as [|p|p].
  Case "g_0". simpl. intros. apply H.
  Case "g_3". intros. apply g_plus3. apply IHgorgeous. apply H0.
  Case "g_5". intros. apply g_plus5. apply IHgorgeous. apply H0.
Qed.

Theorem beautiful__gorgeous : forall n, beautiful n -> gorgeous n.
Proof.
  intros n H. induction H as [ | | | s].
  apply g_0.
  apply g_plus3. apply g_0.
  apply g_plus5. apply g_0.
  apply gorgeous_sum. apply IHbeautiful1. apply IHbeautiful2.
Qed.

Lemma helper_g_times2 : forall x y z, x + (z + y) = z + x + y.
Proof.
  intros. rewrite (plus_comm z x). rewrite plus_assoc. reflexivity.
Qed.

Theorem g_times2: forall n, gorgeous n -> gorgeous (2*n).
Proof.
   intros n H. simpl.
   induction H.
   Case "0". simpl. apply g_0.
   Case "3". apply g_plus3. rewrite plus_0_r.
             rewrite helper_g_times2.
             apply g_plus3. apply gorgeous_sum.
             apply H. apply H.
   Case "5". apply g_plus5. rewrite plus_0_r.
             rewrite helper_g_times2.
             apply g_plus5. apply gorgeous_sum.
             apply H. apply H.
Qed.

Definition even (n:nat) : Prop := 
  evenb n = true.

Inductive ev : nat -> Prop :=
  | ev_0  : ev O
  | ev_SS : forall n:nat, ev n -> ev (S (S n)).

Theorem double_even : forall n, ev (double n).
Proof.
  intros. induction n.
  Case "0". simpl. apply ev_0.
  Case "S n". simpl. apply ev_SS. apply IHn.
Qed.

Theorem ev__even : forall n, ev n -> even n.
Proof.
  intros n E. induction E as [| n' E'].
  Case "E = ev_0".
    unfold even. reflexivity.
  Case "E = ev_SS n' E'".
    unfold even. apply IHE'.
Qed.

Theorem ev_sum : forall n m,
   ev n -> ev m -> ev (n+m).
Proof.
  intros n m Hn Hm. induction Hn as [|p].
  Case "0". simpl. apply Hm.
  Case "S p". simpl. apply ev_SS. apply IHHn.
Qed.

Theorem ev_minus2: forall n,
  ev n -> ev (pred (pred n)).
Proof.
  intros n E.
  inversion E as [| n' E'].
  Case "E = ev_0". simpl. apply ev_0.
  Case "E = ev_SS n' E'". simpl. apply E'. Qed.

Theorem SSev__even : forall n,
  ev (S (S n)) -> ev n.
Proof.
  intros n E.
  inversion E as [| n' E'].
  apply E'. Qed.

Theorem SSSSev__even : forall n,
  ev (S (S (S (S n)))) -> ev n.
Proof.
  intros n E. inversion E as [|n' E'].
  inversion E' as [|n'' E''].
  apply E''. Qed.

Theorem even5_nonsense : 
  ev 5 -> 2 + 2 = 9.
Proof.
  intros E. inversion E. inversion H0. inversion H2.
Qed.

Theorem ev_ev__ev : forall n m,
  ev (n+m) -> ev n -> ev m.
Proof.
  intros n m E En. generalize dependent E.
  induction En.
  Case "ev 0". simpl. intros. apply E.
  Case "ev SS". simpl. intros.
                inversion E.
                apply IHEn in H0.
                apply H0.
Qed.

Inductive pal {X : Type} : list X -> Prop :=
  pal_empty  : pal []
| pal_single : forall (x : X), pal [x]
| pal_step   : forall (x : X) (s : list X) (q : pal s), pal (x :: s ++ [x]).

(* xs ++ snoc (rev xs) x*)
(* pal (x :: xs ++ snoc (rev xs) x) *)
    
Theorem pal_rev1 : forall X (l : list X), pal (l ++ rev l).
Proof.
  intros. induction l as [|x xs].
  Case "[]". simpl. apply pal_empty.
  Case "x :: xs". simpl.
    assert (H : forall Y (ys : list Y) (y : Y), snoc ys y = ys ++ [y]).
    intros Y ys. induction ys as [|z zs].
    SCase "[]". simpl. reflexivity.
    SCase "z :: zs". intros. simpl. rewrite IHzs. reflexivity. 
    assert (Hass : forall Y (bs : list Y) cs ds, bs ++ cs ++ ds = (bs ++ cs) ++ ds).
    intros. induction bs as [|e es].
    SCase "[]". simpl. reflexivity.
    SCase "e :: es". simpl. rewrite IHes. reflexivity.
    rewrite H. rewrite Hass. apply pal_step. apply IHxs.
Qed.

Theorem pal_rev2 : forall X (l : list X), pal l -> l = rev l.
Proof.
  intros X l E. induction E as [|x|x xs].
  Case "nil". reflexivity.
  Case "single". reflexivity.
  Case "rest". simpl.
    assert (H : forall Y (ys : list Y) (y : Y), snoc ys y = ys ++ [y]).
    intros Y ys. induction ys as [|z zs].
    SCase "[]". simpl. reflexivity.
    SCase "z :: zs". intros. simpl. rewrite IHzs. reflexivity.
    rewrite H.
    assert (G : forall Y (ys : list Y) (y : Y), rev (ys ++ [y]) = y :: rev ys).
    intros Y ys. induction ys as [|z zs].
    SCase "[]". simpl. reflexivity.
    SCase "z :: zs". intros. simpl. rewrite IHzs. reflexivity.
    rewrite G.
    rewrite <- IHE.
    assert (F : forall Y (ys : list Y) (y1 y2 : Y)
              , y1 :: ys ++ [y2] = (y1 :: ys) ++ [y2]).
    intros Y ys. destruct ys as [|z zs].
    SCase "[]". simpl. reflexivity.
    SCase "z :: zs". intros. simpl. reflexivity.
    rewrite F.
    reflexivity.
Qed.

Theorem pal_rev3 : forall X (l : list X), l = rev l -> pal l.
Proof.
  intros. induction l as [|x xs].
  Case "[]". apply pal_empty.
  Case "step". simpl in H.
  admit.
Qed.

Inductive subseq {X : Type} : list X -> list X -> Prop :=
  subseq_nil : forall l, subseq [] l
| subseq_inboth : forall x l1 l2, subseq l1 l2 -> subseq (x :: l1) (x :: l2)
| subseq_in2nd  : forall x l1 l2, subseq l1 l2 -> subseq l1 (x :: l2).

Theorem subseq_refl : forall (X : Type) (l : list X), subseq l l.
Proof.
  intros. induction l as [|x xs].
  Case "[]". apply subseq_nil.
  Case "x :: xs". apply subseq_inboth. apply IHxs.
Qed.

Theorem subseq_enlarge_lemma : forall (X : Type) (x : X) (l1 l2 : list X),
  x :: (l1 ++ l2) = (x :: l1) ++ l2.
Proof.
  intros. induction l1 as [|y ys].
  Case "[]". simpl. reflexivity.
  Case "y :: ys". simpl. reflexivity.
Qed.

Theorem subseq_enlarge : forall (X : Type) (l1 l2 l3 : list X),
  subseq l1 l2 -> subseq l1 (l2 ++ l3).
Proof.
  intros X l1 l2 l3 ss. induction ss.
  Case "[]". apply subseq_nil.
  Case "inboth". rewrite <- subseq_enlarge_lemma.
                 apply subseq_inboth. apply IHss.
  Case "in2nd". rewrite <- subseq_enlarge_lemma.
                apply subseq_in2nd. apply IHss.
Qed.

Theorem subseq_trans : forall (X : Type) (l1 l2 l3 : list X),
  subseq l1 l2 -> subseq l2 l3 -> subseq l1 l3.
Proof.
  intros X l1 l2 l3 T12 T23.
  generalize dependent T12.
  generalize dependent l1.
  induction T23.
  Case "[]". intros. inversion T12. apply subseq_nil.
  Case "inboth". intros. inversion T12.
    SCase "[]". apply subseq_nil.
    SCase "inboth". apply subseq_inboth. apply IHT23. apply H1.
    SCase "in2nd". apply subseq_in2nd. apply IHT23. apply H1.
  Case "in2nd". intros. apply subseq_in2nd. apply IHT23. apply T12.
Qed.
